<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Food HS Code Classifier</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useCallback } = React;
        const { Upload, Download, Search, AlertCircle, CheckCircle, Eye, Info } = lucide;

        const FuzzyMatchingApp = () => {
          const [tariffData, setTariffData] = useState([]);
          const [inventoryData, setInventoryData] = useState([]);
          const [matches, setMatches] = useState([]);
          const [isProcessing, setIsProcessing] = useState(false);
          const [minScore, setMinScore] = useState(0.3);
          const [showDebug, setShowDebug] = useState(false);
          const [debugInfo, setDebugInfo] = useState({ tariff: {}, inventory: {} });

          // HS Chapter categories
          const hsChapterCategories = {
            '01': 'Live Animals',
            '02': 'Meat and Edible Meat Offal',
            '03': 'Fish, Crustaceans, Molluscs',
            '04': 'Dairy Produce; Eggs; Honey',
            '07': 'Edible Vegetables and Certain Roots and Tubers',
            '08': 'Edible Fruit and Nuts',
            '09': 'Coffee, Tea, Maté and Spices',
            '10': 'Cereals',
            '11': 'Products of the Milling Industry',
            '15': 'Animal or Vegetable Fats and Oils',
            '16': 'Preparations of Meat, Fish, or Crustaceans',
            '17': 'Sugars and Sugar Confectionery',
            '19': 'Preparations of Cereals, Flour, Starch or Milk',
            '20': 'Preparations of Vegetables, Fruit, Nuts',
            '21': 'Miscellaneous Edible Preparations',
            '22': 'Beverages, Spirits and Vinegar'
          };

          const getHsChapterCode = (hsCode) => {
            if (!hsCode) return '';
            const digits = String(hsCode).replace(/\D/g, '');
            if (digits.length < 2) return '';
            return digits.slice(0, 2).padStart(2, '0');
          };

          const getHsCategory = (hsCode) => {
            const chapter = getHsChapterCode(hsCode);
            return hsChapterCategories[chapter] || '';
          };

          // CSV parsing
          const parseCSV = (csvText) => {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length === 0) return { data: [], originalHeaders: [], normalizedHeaders: [], delimiter: ',' };

            const delimiters = [',', ';', '\t', '|'];
            let bestDelimiter = ',';
            let maxColumns = 0;

            for (const delimiter of delimiters) {
              const testColumns = lines[0].split(delimiter).length;
              if (testColumns > maxColumns) {
                maxColumns = testColumns;
                bestDelimiter = delimiter;
              }
            }

            const originalHeaders = lines[0]
              .split(bestDelimiter)
              .map(h => h.trim().replace(/^["']|["']$/g, ''));
            
            const normalizedHeaders = originalHeaders.map(h => h.toLowerCase());

            const data = lines.slice(1).map(line => {
              const values = line.split(bestDelimiter).map(v => v.trim().replace(/^["']|["']$/g, ''));
              const obj = {};
              originalHeaders.forEach((header, index) => {
                obj[header] = values[index] || '';
              });
              return obj;
            }).filter(row => Object.values(row).some(val => String(val).trim()));

            return { data, originalHeaders, normalizedHeaders, delimiter: bestDelimiter };
          };

          // Column detection
          const detectColumns = (originalHeaders, type) => {
            const mapping = {};
            
            if (type === 'tariff') {
              const descPatterns = ['description', 'product', 'commodity', 'item', 'goods', 'desc'];
              const descCol = originalHeaders.find(h => 
                descPatterns.some(pattern => h.toLowerCase().includes(pattern))
              );
              
              const hsPatterns = ['hs', 'code', 'tariff', 'classification'];
              const hsCol = originalHeaders.find(h => 
                hsPatterns.some(pattern => h.toLowerCase().includes(pattern))
              );
              
              mapping.description = descCol;
              mapping.hsCode = hsCol;
            } else {
              const namePatterns = ['name', 'product', 'item', 'title', 'description', 'inventory'];
              const nameCol = originalHeaders.find(h => 
                namePatterns.some(pattern => h.toLowerCase().includes(pattern))
              );
              
              mapping.name = nameCol;
            }
            
            return mapping;
          };

          // Fuzzy matching utilities
          const levenshteinDistance = (str1, str2) => {
            const rows = str2.length + 1;
            const cols = str1.length + 1;
            const matrix = Array.from({ length: rows }, () => Array(cols).fill(0));

            for (let i = 0; i < rows; i++) matrix[i][0] = i;
            for (let j = 0; j < cols; j++) matrix[0][j] = j;

            for (let i = 1; i < rows; i++) {
              for (let j = 1; j < cols; j++) {
                if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                  matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                  matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                  );
                }
              }
            }
            return matrix[rows - 1][cols - 1];
          };

          const normalizeString = (str) => {
            if (!str) return '';
            return str.toLowerCase()
              .replace(/[^\w\s]/g, ' ')
              .replace(/\s+/g, ' ')
              .trim();
          };

          const extractKeywords = (text) => {
            if (!text) return [];
            const stopWords = new Set(['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'a', 'an']);
            return normalizeString(text)
              .split(' ')
              .filter(word => word.length > 2 && !stopWords.has(word));
          };

          const calculateSimilarityScore = (str1, str2) => {
            const norm1 = normalizeString(str1);
            const norm2 = normalizeString(str2);
            
            if (norm1 === norm2) return 1.0;
            if (!norm1 || !norm2) return 0;
            
            const distance = levenshteinDistance(norm1, norm2);
            const maxLen = Math.max(norm1.length, norm2.length);
            
            return 1 - (distance / maxLen);
          };

          const findBestMatch = (inventoryItem, tariffMapping, inventoryMapping) => {
            const nameKey = inventoryMapping.name;
            const descKey = tariffMapping.description;
            const hsKey = tariffMapping.hsCode;
            const inventoryName = inventoryItem[nameKey];
            if (!inventoryName) return null;

            let bestMatch = null;
            let bestScore = 0;

            for (const tariffItem of tariffData) {
              const tariffDescription = tariffItem[descKey];
              const hsCodeValue = tariffItem[hsKey] || '';

              if (!tariffDescription) continue;

              const score = calculateSimilarityScore(inventoryName, tariffDescription);
              
              if (score > bestScore && score >= minScore) {
                bestScore = score;
                bestMatch = {
                  description: tariffDescription,
                  hsCode: hsCodeValue,
                  category: getHsCategory(hsCodeValue),
                  score: score
                };
              }
            }

            return bestMatch;
          };

          const handleFileUpload = (event, type) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const result = e?.target?.result;
                if (typeof result !== 'string') {
                  alert(Error parsing  file: could not read as text.);
                  return;
                }
                const { data, originalHeaders, delimiter } = parseCSV(result);
                
                const columnMapping = detectColumns(originalHeaders, type);
                
                if (type === 'tariff') {
                  setTariffData(data);
                  setDebugInfo(prev => ({
                    ...prev,
                    tariff: {
                      headers: originalHeaders,
                      mapping: columnMapping,
                      sampleData: data.slice(0, 3),
                      delimiter,
                      count: data.length
                    }
                  }));
                } else {
                  setInventoryData(data);
                  setDebugInfo(prev => ({
                    ...prev,
                    inventory: {
                      headers: originalHeaders,
                      mapping: columnMapping,
                      sampleData: data.slice(0, 3),
                      delimiter,
                      count: data.length
                    }
                  }));
                }
              } catch (error) {
                alert(Error parsing  file: );
              }
            };
            reader.readAsText(file);
          };

          const processMatching = useCallback(() => {
            if (tariffData.length === 0 || inventoryData.length === 0) {
              alert('Please upload both tariff and inventory files first.');
              return;
            }

            const tariffMapping = debugInfo.tariff.mapping;
            const inventoryMapping = debugInfo.inventory.mapping;

            if (!tariffMapping.description || !inventoryMapping.name) {
              alert('Could not detect required columns. Please check your CSV files.');
              return;
            }

            setIsProcessing(true);
            
            setTimeout(() => {
              const nameKey = inventoryMapping.name;
              const results = inventoryData.map(item => {
                const match = findBestMatch(item, tariffMapping, inventoryMapping);
                return {
                  inventory: item,
                  inventoryName: item[nameKey],
                  match,
                  category: match?.category || '',
                  status: match ? 'matched' : 'unmatched'
                };
              });
              
              setMatches(results);
              setIsProcessing(false);
            }, 100);
          }, [tariffData, inventoryData, minScore, debugInfo]);

          const exportResults = () => {
            const tariffMapping = debugInfo.tariff.mapping;
            const inventoryMapping = debugInfo.inventory.mapping;

            const csvContent = [
              ['Inventory Name', 'Matched Description', 'HS Code', 'Category', 'Confidence Score', 'Status'],
              ...matches.map(m => [
                m.inventoryName || '',
                m.match?.description || 'No match found',
                m.match?.hsCode || '',
                m.match?.category || '',
                m.match?.score ? (m.match.score * 100).toFixed(1) + '%' : '0%',
                m.status
              ])
            ].map(row => row.map(cell => "").join(',')).join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fuzzy_matching_results.csv';
            a.click();
            window.URL.revokeObjectURL(url);
          };

          return (
            <div className="min-h-screen bg-gray-50 p-6">
              <div className="max-w-7xl mx-auto">
                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                  <h1 className="text-3xl font-bold text-gray-800 mb-2">
                    Inventory to Tariff Fuzzy Matching Tool
                  </h1>
                  <p className="text-gray-600 mb-6">
                    Upload your tariff schedule and inventory data to find the best HS code matches using advanced fuzzy matching algorithms.
                  </p>

                  {/* Debug Toggle */}
                  <div className="mb-4">
                    <button
                      onClick={() => setShowDebug(!showDebug)}
                      className="flex items-center gap-2 text-sm text-blue-600 hover:text-blue-800"
                    >
                      <Info className="h-4 w-4" />
                      {showDebug ? 'Hide' : 'Show'} Debug Information
                    </button>
                  </div>

                  {/* Debug Information */}
                  {showDebug && (
                    <div className="grid md:grid-cols-2 gap-4 mb-6 p-4 bg-gray-50 rounded-lg">
                      <div>
                        <h4 className="font-semibold text-gray-700 mb-2">Tariff File Debug</h4>
                        {debugInfo.tariff.headers && (
                          <div className="text-sm space-y-1">
                            <p><strong>Headers:</strong> {debugInfo.tariff.headers.join(', ')}</p>
                            <p><strong>Description Column:</strong> {debugInfo.tariff.mapping?.description || 'Not detected'}</p>
                            <p><strong>HS Code Column:</strong> {debugInfo.tariff.mapping?.hsCode || 'Not detected'}</p>
                            <p><strong>Records:</strong> {debugInfo.tariff.count}</p>
                          </div>
                        )}
                      </div>
                      <div>
                        <h4 className="font-semibold text-gray-700 mb-2">Inventory File Debug</h4>
                        {debugInfo.inventory.headers && (
                          <div className="text-sm space-y-1">
                            <p><strong>Headers:</strong> {debugInfo.inventory.headers.join(', ')}</p>
                            <p><strong>Name Column:</strong> {debugInfo.inventory.mapping?.name || 'Not detected'}</p>
                            <p><strong>Records:</strong> {debugInfo.inventory.count}</p>
                          </div>
                        )}
                      </div>
                    </div>
                  )}

                  {/* File Upload Section */}
                  <div className="grid md:grid-cols-2 gap-6 mb-6">
                    <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
                      <div className="text-center">
                        <Upload className="mx-auto h-12 w-12 text-gray-400 mb-4" />
                        <h3 className="text-lg font-semibold mb-2">Tariff Schedule (Reference)</h3>
                        <p className="text-sm text-gray-600 mb-4">
                          CSV with Description and HS Code columns
                        </p>
                        <input
                          type="file"
                          accept=".csv"
                          onChange={(e) => handleFileUpload(e, 'tariff')}
                          className="hidden"
                          id="tariff-upload"
                        />
                        <label
                          htmlFor="tariff-upload"
                          className="bg-blue-500 text-white px-4 py-2 rounded cursor-pointer hover:bg-blue-600"
                        >
                          Upload Tariff CSV
                        </label>
                        {tariffData.length > 0 && (
                          <div className="mt-2 space-y-1">
                            <p className="text-green-600">✓ {tariffData.length} items loaded</p>
                            {debugInfo.tariff.mapping?.description && (
                              <p className="text-xs text-gray-600">
                                Using: {debugInfo.tariff.mapping.description} → {debugInfo.tariff.mapping.hsCode}
                              </p>
                            )}
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
                      <div className="text-center">
                        <Upload className="mx-auto h-12 w-12 text-gray-400 mb-4" />
                        <h3 className="text-lg font-semibold mb-2">Inventory Data</h3>
                        <p className="text-sm text-gray-600 mb-4">
                          CSV with product/item name column
                        </p>
                        <input
                          type="file"
                          accept=".csv"
                          onChange={(e) => handleFileUpload(e, 'inventory')}
                          className="hidden"
                          id="inventory-upload"
                        />
                        <label
                          htmlFor="inventory-upload"
                          className="bg-green-500 text-white px-4 py-2 rounded cursor-pointer hover:bg-green-600"
                        >
                          Upload Inventory CSV
                        </label>
                        {inventoryData.length > 0 && (
                          <div className="mt-2 space-y-1">
                            <p className="text-green-600">✓ {inventoryData.length} items loaded</p>
                            {debugInfo.inventory.mapping?.name && (
                              <p className="text-xs text-gray-600">
                                Using: {debugInfo.inventory.mapping.name}
                              </p>
                            )}
                          </div>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Settings and Controls */}
                  <div className="flex items-center gap-4 mb-6">
                    <div className="flex items-center gap-2">
                      <label className="text-sm font-medium">Minimum Score:</label>
                      <input
                        type="range"
                        min="0.1"
                        max="1"
                        step="0.1"
                        value={minScore}
                        onChange={(e) => setMinScore(parseFloat(e.target.value))}
                        className="w-32"
                      />
                      <span className="text-sm text-gray-600">{(minScore * 100).toFixed(0)}%</span>
                    </div>
                    
                    <button
                      onClick={processMatching}
                      disabled={isProcessing || tariffData.length === 0 || inventoryData.length === 0}
                      className="bg-purple-500 text-white px-6 py-2 rounded hover:bg-purple-600 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center gap-2"
                    >
                      <Search className="h-4 w-4" />
                      {isProcessing ? 'Processing...' : 'Start Matching'}
                    </button>

                    {matches.length > 0 && (
                      <button
                        onClick={exportResults}
                        className="bg-indigo-500 text-white px-6 py-2 rounded hover:bg-indigo-600 flex items-center gap-2"
                      >
                        <Download className="h-4 w-4" />
                        Export Results
                      </button>
                    )}
                  </div>

                  {/* Results Summary */}
                  {matches.length > 0 && (
                    <div className="grid grid-cols-3 gap-4 mb-6">
                      <div className="bg-green-50 p-4 rounded-lg text-center">
                        <div className="text-2xl font-bold text-green-600">
                          {matches.filter(m => m.status === 'matched').length}
                        </div>
                        <div className="text-green-700">Matched</div>
                      </div>
                      <div className="bg-red-50 p-4 rounded-lg text-center">
                        <div className="text-2xl font-bold text-red-600">
                          {matches.filter(m => m.status === 'unmatched').length}
                        </div>
                        <div className="text-red-700">Unmatched</div>
                      </div>
                      <div className="bg-blue-50 p-4 rounded-lg text-center">
                        <div className="text-2xl font-bold text-blue-600">
                          {matches.length > 0 ? ((matches.filter(m => m.status === 'matched').length / matches.length) * 100).toFixed(1) : 0}%
                        </div>
                        <div className="text-blue-700">Success Rate</div>
                      </div>
                    </div>
                  )}
                </div>

                {/* Results Table */}
                {matches.length > 0 && (
                  <div className="bg-white rounded-lg shadow-lg overflow-hidden">
                    <div className="px-6 py-4 border-b border-gray-200">
                      <h2 className="text-xl font-semibold">Matching Results</h2>
                    </div>
                    <div className="overflow-x-auto max-h-96">
                      <table className="w-full">
                        <thead className="bg-gray-50 sticky top-0">
                          <tr>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                              Inventory Item
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                              Matched Description
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                              HS Code
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                              Category
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                              Score
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                              Status
                            </th>
                          </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                          {matches.map((match, index) => (
                            <tr key={index} className={match.status === 'matched' ? 'bg-green-50' : 'bg-red-50'}>
                              <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                                {match.inventoryName}
                              </td>
                              <td className="px-6 py-4 text-sm text-gray-900">
                                {match.match?.description || 'No match found'}
                              </td>
                              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900 font-mono">
                                {match.match?.hsCode || '-'}
                              </td>
                              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                                {match.match?.category || '-'}
                              </td>
                              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                                {match.match ? (
                                  <div className="flex items-center gap-2">
                                    <div className="w-16 bg-gray-200 rounded-full h-2">
                                      <div
                                        className="bg-blue-500 h-2 rounded-full"
                                        style={{ width: ${match.match.score * 100}% }}
                                      ></div>
                                    </div>
                                    <span>{(match.match.score * 100).toFixed(1)}%</span>
                                  </div>
                                ) : '0%'}
                              </td>
                              <td className="px-6 py-4 whitespace-nowrap">
                                {match.status === 'matched' ? (
                                  <div className="flex items-center text-green-600">
                                    <CheckCircle className="h-4 w-4 mr-1" />
                                    Matched
                                  </div>
                                ) : (
                                  <div className="flex items-center text-red-600">
                                    <AlertCircle className="h-4 w-4 mr-1" />
                                    Unmatched
                                  </div>
                                )}
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        };

        ReactDOM.render(<FuzzyMatchingApp />, document.getElementById('root'));
    </script>
</body>
</html>
